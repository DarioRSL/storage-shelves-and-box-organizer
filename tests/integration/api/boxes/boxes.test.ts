/**
 * Integration Tests: Box Management
 *
 * Tests for:
 * - GET /api/boxes - List boxes
 * - POST /api/boxes - Create box
 * - POST /api/boxes/check-duplicate - Check for duplicate box names
 *
 * Coverage:
 * - Box listing with workspace filtering
 * - Box creation with auto-generated short_id and search_vector (database triggers)
 * - QR code assignment during creation
 * - Duplicate name checking
 * - RLS policy enforcement
 * - Input validation
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { clearAllTestData, seedTable } from '../../../helpers/db-setup';
import { createAuthenticatedUser } from '../../../helpers/auth-helper';
import { seedInitialDataset } from '../../../fixtures/initial-dataset';
import {
  createWorkspaceFixture,
  createRootLocationFixture,
  createBoxFixture,
  createQRCodeFixture,
} from '../../../helpers/factory';
import {
  authenticatedGet,
  authenticatedPost,
  assertSuccess,
  assertError,
} from '../../../helpers/api-client';
import { getAdminSupabaseClient } from '../../../helpers/supabase-test-client';

describe.skip('GET /api/boxes', () => {
  beforeEach(async () => {
    await clearAllTestData();
  });

  afterEach(async () => {
    await clearAllTestData();
  });

  describe('Success Cases', () => {
    it('should list all boxes for workspace', async () => {
      // Arrange: Create dataset with boxes
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act: Get boxes
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}`,
        adminUser.token
      );

      // Assert: Should return boxes
      assertSuccess(response);
      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBeGreaterThan(0);

      // Verify all boxes belong to the workspace
      response.body.forEach((box: any) => {
        expect(box.workspace_id).toBe(primaryWorkspaceId);
      });
    });

    it.skip('should include box metadata in response', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}`,
        adminUser.token
      );

      // Assert: Check response structure
      assertSuccess(response);
      const box = response.body[0];
      expect(box).toHaveProperty('id');
      expect(box).toHaveProperty('workspace_id');
      expect(box).toHaveProperty('name');
      expect(box).toHaveProperty('short_id'); // Auto-generated by trigger
      expect(box).toHaveProperty('description');
      expect(box).toHaveProperty('tags');
      expect(box).toHaveProperty('status');
      expect(box).toHaveProperty('location_id');
      expect(box).toHaveProperty('created_at');
      expect(box).toHaveProperty('updated_at');
    });

    it.skip('should filter boxes by location_id', async () => {
      // Arrange: Create boxes in different locations
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const location1Data = createRootLocationFixture(primaryWorkspaceId, 'Location 1');
      const location2Data = createRootLocationFixture(primaryWorkspaceId, 'Location 2');
      const [location1, location2] = await adminClient
        .from('locations')
        .insert([location1Data, location2Data])
        .select()
        .throwOnError();

      // Create boxes in location1
      const boxesData = [
        createBoxFixture(primaryWorkspaceId, location1.id, 'Box in Location 1'),
        createBoxFixture(primaryWorkspaceId, location2.id, 'Box in Location 2'),
      ];
      await seedTable('boxes', boxesData);

      // Act: Filter by location1
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}&location_id=${location1.id}`,
        adminUser.token
      );

      // Assert: Should only return boxes from location1
      assertSuccess(response);
      expect(response.body.length).toBe(1);
      expect(response.body[0].location_id).toBe(location1.id);
    });

    it.skip('should filter boxes by status', async () => {
      // Arrange: Create boxes with different statuses
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Create boxes with different statuses
      const boxesData = [
        { ...createBoxFixture(primaryWorkspaceId, location.id, 'Active Box'), status: 'active' },
        {
          ...createBoxFixture(primaryWorkspaceId, location.id, 'Archived Box'),
          status: 'archived',
        },
      ];
      await seedTable('boxes', boxesData);

      // Act: Filter by status=active
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}&status=active`,
        adminUser.token
      );

      // Assert: Should only return active boxes
      assertSuccess(response);
      expect(response.body.length).toBe(1);
      expect(response.body[0].status).toBe('active');
    });

    it.skip('should include QR code details for boxes with assigned QR codes', async () => {
      // Arrange: Create box with QR code
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Create QR code
      const qrData = createQRCodeFixture(primaryWorkspaceId);
      const [qrCode] = await seedTable('qr_codes', [qrData]);

      // Create box with QR
      const boxData = {
        ...createBoxFixture(primaryWorkspaceId, location.id, 'Box With QR'),
        qr_code_id: qrCode.id,
      };
      await seedTable('boxes', [boxData]);

      // Act
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}`,
        adminUser.token
      );

      // Assert: Should include QR code details
      assertSuccess(response);
      const boxWithQR = response.body.find((b: any) => b.qr_code_id === qrCode.id);
      expect(boxWithQR).toBeTruthy();
      expect(boxWithQR.qr_code_id).toBe(qrCode.id);
    });

    it.skip('should return empty array if workspace has no boxes', async () => {
      // Arrange: Create user with empty workspace
      const testUser = await createAuthenticatedUser({
        email: 'no-boxes@example.com',
        password: 'SecurePass123!',
        full_name: 'No Boxes User',
      });

      const adminClient = getAdminSupabaseClient();
      const workspaceData = createWorkspaceFixture(testUser.id);
      const [workspace] = await adminClient
        .from('workspaces')
        .insert(workspaceData)
        .select()
        .throwOnError();

      // Add user as owner
      await adminClient
        .from('workspace_members')
        .insert({
          workspace_id: workspace.id,
          user_id: testUser.id,
          role: 'owner',
        })
        .throwOnError();

      // Act
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${workspace.id}`,
        testUser.token
      );

      // Assert
      assertSuccess(response);
      expect(response.status).toBe(200);
      expect(response.body).toEqual([]);
    });

    it.skip('should return only boxes user has access to via RLS', async () => {
      // Arrange: Create two separate workspaces
      const dataset = await seedInitialDataset();
      const viewerUser = dataset.users.viewer;
      const secondaryWorkspaceId = dataset.workspaces.secondary.id;

      // Act: Viewer is only member of primary workspace, not secondary
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${secondaryWorkspaceId}`,
        viewerUser.token
      );

      // Assert: Should get 403 or empty array (RLS blocks access)
      if (response.status === 403) {
        assertError(response, 403);
      } else {
        assertSuccess(response);
        expect(response.body).toEqual([]);
      }
    });
  });

  describe.skip('Validation Errors (400)', () => {
    it('should reject request without workspace_id', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;

      // Act: Missing workspace_id query param
      const response = await authenticatedGet('/api/boxes', adminUser.token);

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with invalid workspace_id format', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;

      // Act: Invalid UUID format
      const response = await authenticatedGet('/api/boxes?workspace_id=not-a-uuid', adminUser.token);

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with invalid status filter', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act: Invalid status value
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}&status=invalid_status`,
        adminUser.token
      );

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authentication Errors (401)', () => {
    it('should reject request without authentication', async () => {
      // Act: Try to get boxes without token
      const response = await authenticatedGet('/api/boxes?workspace_id=123', '');

      // Assert
      assertError(response, 401);
      expect(response.body).toHaveProperty('error');
    });

    it.skip('should reject request with invalid token', async () => {
      // Act
      const response = await authenticatedGet(
        '/api/boxes?workspace_id=123',
        'invalid.jwt.token'
      );

      // Assert
      assertError(response, 401);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authorization Errors (403)', () => {
    it('should reject request from non-member', async () => {
      // Arrange: Create workspace and outsider
      const dataset = await seedInitialDataset();
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const outsider = await createAuthenticatedUser({
        email: 'box-outsider@example.com',
        password: 'SecurePass123!',
        full_name: 'Box Outsider User',
      });

      // Act: Outsider tries to access workspace boxes
      const response = await authenticatedGet(
        `/api/boxes?workspace_id=${primaryWorkspaceId}`,
        outsider.token
      );

      // Assert: Should be blocked
      assertError(response, 403);
      expect(response.body).toHaveProperty('error');
    });
  });
});

describe.skip('POST /api/boxes', () => {
  beforeEach(async () => {
    await clearAllTestData();
  });

  afterEach(async () => {
    await clearAllTestData();
  });

  describe('Success Cases', () => {
    it.skip('should create box with valid data', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'New Box',
        description: 'Test box description',
        tags: ['electronics', 'cables'],
      });

      // Assert
      assertSuccess(response);
      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('id');
      expect(response.body.name).toBe('New Box');
      expect(response.body.description).toBe('Test box description');
      expect(response.body.tags).toEqual(['electronics', 'cables']);
      expect(response.body.workspace_id).toBe(primaryWorkspaceId);
      expect(response.body.location_id).toBe(location.id);
    });

    it.skip('should auto-generate short_id via database trigger', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box With Auto Short ID',
      });

      // Assert: short_id should be auto-generated (10 chars, alphanumeric)
      assertSuccess(response);
      expect(response.body).toHaveProperty('short_id');
      expect(response.body.short_id).toMatch(/^[A-Za-z0-9]{10}$/);
    });

    it.skip('should auto-generate search_vector via database trigger', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Searchable Box',
        description: 'Contains important items',
        tags: ['searchable', 'test'],
      });

      assertSuccess(response);
      const boxId = response.body.id;

      // Assert: search_vector should be created (verify via direct DB query)
      const { data: box } = await adminClient
        .from('boxes')
        .select('search_vector')
        .eq('id', boxId)
        .single();

      expect(box.search_vector).toBeTruthy();
    });

    it.skip('should create box with QR code assignment', async () => {
      // Arrange: Create QR code first
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Create QR code
      const qrData = createQRCodeFixture(primaryWorkspaceId);
      const [qrCode] = await seedTable('qr_codes', [qrData]);

      // Act: Create box with QR assignment
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box With QR',
        qr_code_id: qrCode.id,
      });

      // Assert
      assertSuccess(response);
      expect(response.status).toBe(201);
      expect(response.body.qr_code_id).toBe(qrCode.id);

      // Verify QR code status updated to "assigned"
      const { data: updatedQR } = await adminClient
        .from('qr_codes')
        .select('status')
        .eq('id', qrCode.id)
        .single();

      expect(updatedQR.status).toBe('assigned');
    });

    it.skip('should create box without QR code', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box without QR
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box Without QR',
      });

      // Assert
      assertSuccess(response);
      expect(response.status).toBe(201);
      expect(response.body.qr_code_id).toBeNull();
    });

    it.skip('should create box without description', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box without description
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box Without Description',
      });

      // Assert
      assertSuccess(response);
      expect(response.status).toBe(201);
      expect(response.body.name).toBe('Box Without Description');
      expect(response.body.description).toBeNull();
    });

    it.skip('should create box without tags', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box without tags
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box Without Tags',
      });

      // Assert
      assertSuccess(response);
      expect(response.body.tags).toEqual([]);
    });

    it.skip('should create box with default status "active"', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Create box without status
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box With Default Status',
      });

      // Assert: Default status should be "active"
      assertSuccess(response);
      expect(response.body.status).toBe('active');
    });
  });

  describe.skip('Validation Errors (400)', () => {
    it('should reject box with empty name', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: '',
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with missing name', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with name exceeding max length', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Name > 100 chars
      const longName = 'A'.repeat(101);
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: longName,
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with description exceeding max length', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Description > 1000 chars
      const longDescription = 'A'.repeat(1001);
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Valid Name',
        description: longDescription,
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with invalid location_id', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act: Non-existent location
      const fakeLocationId = '00000000-0000-0000-0000-000000000001';
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: fakeLocationId,
        name: 'Box With Invalid Location',
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with invalid workspace_id', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;

      // Act
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: 'not-a-uuid',
        location_id: '00000000-0000-0000-0000-000000000001',
        name: 'Box',
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box with invalid status', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Act: Invalid status value
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Box',
        status: 'invalid_status',
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authentication Errors (401)', () => {
    it('should reject box creation without authentication', async () => {
      // Act
      const response = await authenticatedPost('/api/boxes', '', {
        workspace_id: '00000000-0000-0000-0000-000000000000',
        location_id: '00000000-0000-0000-0000-000000000001',
        name: 'Unauthenticated Box',
      });

      // Assert
      assertError(response, 401);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject box creation with invalid token', async () => {
      // Act
      const response = await authenticatedPost('/api/boxes', 'invalid.jwt.token', {
        workspace_id: '00000000-0000-0000-0000-000000000000',
        location_id: '00000000-0000-0000-0000-000000000001',
        name: 'Invalid Token Box',
      });

      // Assert
      assertError(response, 401);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authorization Errors (403)', () => {
    it('should reject box creation in other workspace', async () => {
      // Arrange: Create workspace and outsider
      const dataset = await seedInitialDataset();
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      const outsider = await createAuthenticatedUser({
        email: 'box-creation-outsider@example.com',
        password: 'SecurePass123!',
        full_name: 'Box Creation Outsider',
      });

      // Act: Outsider tries to create box in primary workspace
      const response = await authenticatedPost('/api/boxes', outsider.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'Unauthorized Box',
      });

      // Assert
      assertError(response, 403);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Conflict Errors (409)', () => {
    it('should reject assigning already-assigned QR code', async () => {
      // Arrange: Create box with QR code assigned
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      // Create QR and assign it to a box
      const qrData = createQRCodeFixture(primaryWorkspaceId);
      const [qrCode] = await seedTable('qr_codes', [qrData]);

      const boxData = {
        ...createBoxFixture(primaryWorkspaceId, location.id, 'Existing Box'),
        qr_code_id: qrCode.id,
      };
      await seedTable('boxes', [boxData]);

      // Act: Try to create another box with the same QR
      const response = await authenticatedPost('/api/boxes', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        location_id: location.id,
        name: 'New Box',
        qr_code_id: qrCode.id,
      });

      // Assert
      assertError(response, 409);
      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toMatch(/already.*assigned|conflict/i);
    });
  });
});

describe.skip('POST /api/boxes/check-duplicate', () => {
  beforeEach(async () => {
    await clearAllTestData();
  });

  afterEach(async () => {
    await clearAllTestData();
  });

  describe('Success Cases', () => {
    it.skip('should return true if box name exists in workspace', async () => {
      // Arrange: Create box
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      const boxData = createBoxFixture(primaryWorkspaceId, location.id, 'Existing Box');
      await seedTable('boxes', [boxData]);

      // Act: Check for duplicate name
      const response = await authenticatedPost('/api/boxes/check-duplicate', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        name: 'Existing Box',
      });

      // Assert
      assertSuccess(response);
      expect(response.body.exists).toBe(true);
    });

    it.skip('should return false if box name does not exist', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act: Check for non-existent name
      const response = await authenticatedPost('/api/boxes/check-duplicate', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        name: 'Unique Box Name',
      });

      // Assert
      assertSuccess(response);
      expect(response.body.exists).toBe(false);
    });

    it.skip('should be case-insensitive when checking duplicates', async () => {
      // Arrange: Create box with lowercase name
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const adminClient = getAdminSupabaseClient();
      const locationData = createRootLocationFixture(primaryWorkspaceId, 'Location');
      const [location] = await adminClient
        .from('locations')
        .insert(locationData)
        .select()
        .throwOnError();

      const boxData = createBoxFixture(primaryWorkspaceId, location.id, 'existing box');
      await seedTable('boxes', [boxData]);

      // Act: Check with uppercase
      const response = await authenticatedPost('/api/boxes/check-duplicate', adminUser.token, {
        workspace_id: primaryWorkspaceId,
        name: 'EXISTING BOX',
      });

      // Assert: Should find duplicate (case-insensitive)
      assertSuccess(response);
      expect(response.body.exists).toBe(true);
    });
  });

  describe.skip('Validation Errors (400)', () => {
    it('should reject check with missing workspace_id', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;

      // Act
      const response = await authenticatedPost('/api/boxes/check-duplicate', adminUser.token, {
        name: 'Box Name',
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject check with missing name', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const adminUser = dataset.users.admin;
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      // Act
      const response = await authenticatedPost('/api/boxes/check-duplicate', adminUser.token, {
        workspace_id: primaryWorkspaceId,
      });

      // Assert
      assertError(response, 400);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authentication Errors (401)', () => {
    it('should reject check without authentication', async () => {
      // Act
      const response = await authenticatedPost('/api/boxes/check-duplicate', '', {
        workspace_id: '00000000-0000-0000-0000-000000000000',
        name: 'Box',
      });

      // Assert
      assertError(response, 401);
      expect(response.body).toHaveProperty('error');
    });
  });

  describe.skip('Authorization Errors (403)', () => {
    it('should reject check from non-member', async () => {
      // Arrange
      const dataset = await seedInitialDataset();
      const primaryWorkspaceId = dataset.workspaces.primary.id;

      const outsider = await createAuthenticatedUser({
        email: 'duplicate-check-outsider@example.com',
        password: 'SecurePass123!',
        full_name: 'Duplicate Check Outsider',
      });

      // Act: Outsider tries to check duplicates
      const response = await authenticatedPost('/api/boxes/check-duplicate', outsider.token, {
        workspace_id: primaryWorkspaceId,
        name: 'Box',
      });

      // Assert
      assertError(response, 403);
      expect(response.body).toHaveProperty('error');
    });
  });
});
