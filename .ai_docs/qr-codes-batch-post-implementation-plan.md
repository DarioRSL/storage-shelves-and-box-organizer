# API Endpoint Implementation Plan: POST /api/qr-codes/batch

## 1. Endpoint Overview

This endpoint generates a batch of new, unassigned QR codes for a workspace. These QR codes can then be printed as physical labels and later assigned to boxes. The endpoint creates multiple QR code records with unique short IDs in the format `QR-XXXXXX` (6 uppercase alphanumeric characters) and sets their initial status to `generated`.

**Purpose:** Batch generation of QR codes for printing
**Primary Use Case:** Allowing users to pre-generate QR code labels before creating boxes

## 2. Request Details

- **HTTP Method:** POST
- **URL Structure:** `/api/qr-codes/batch`
- **Parameters:** None (URL parameters)
- **Request Headers:**
  - `Authorization: Bearer <token>` (required)
  - `Content-Type: application/json` (required)
- **Request Body:**

```json
{
  "workspace_id": "uuid",
  "quantity": 20
}
```

**Request Body Fields:**
- `workspace_id` (string, required): UUID of the workspace to generate QR codes for
- `quantity` (number, required): Number of QR codes to generate (min: 1, max: 100)

**Example Request:**
```bash
curl -X POST http://localhost:3000/api/qr-codes/batch \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -H "Content-Type: application/json" \
  -d '{
    "workspace_id": "550e8400-e29b-41d4-a716-446655440000",
    "quantity": 20
  }'
```

## 3. Utilized Types

From `src/types.ts`:

**Existing Types:**
- `BatchGenerateQrCodesRequest`: Request body structure (already exists)
- `BatchGenerateQrCodesResponse`: Response structure (already exists)
- `QrStatus`: Enum type for QR code status
- `ErrorResponse`: Standard error response structure

**Type Definitions (already in types.ts):**

```typescript
/**
 * Request to generate a batch of QR codes.
 */
export interface BatchGenerateQrCodesRequest {
  workspace_id: string;
  quantity: number;
}

/**
 * Response wrapper for batch QR code generation.
 * Returns array of generated QR codes with their short_ids for printing.
 */
export interface BatchGenerateQrCodesResponse {
  data: {
    id: string;
    short_id: string;
    status: QrStatus;
    workspace_id: string;
    created_at: string | null;
  }[];
}
```

**Zod Validation Schema:**

```typescript
import { z } from 'zod';
import { ValidationRules } from '@/types';

export const BatchGenerateQrCodesRequestSchema = z.object({
  workspace_id: z.string().uuid('Nieprawidłowy format workspace_id'),
  quantity: z.number()
    .int('Ilość musi być liczbą całkowitą')
    .min(ValidationRules.qrCodes.MIN_BATCH_QUANTITY, 'Ilość musi wynosić co najmniej 1')
    .max(ValidationRules.qrCodes.MAX_BATCH_QUANTITY, 'Ilość nie może przekraczać 100'),
});
```

## 4. Response Details

**Success Response (201 Created):**

```json
{
  "data": [
    {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "short_id": "QR-A1B2C3",
      "status": "generated",
      "workspace_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2023-10-27T10:00:00Z"
    },
    {
      "id": "223e4567-e89b-12d3-a456-426614174001",
      "short_id": "QR-D4E5F6",
      "status": "generated",
      "workspace_id": "550e8400-e29b-41d4-a716-446655440000",
      "created_at": "2023-10-27T10:00:00Z"
    }
  ]
}
```

**Status Codes:**
- `201 Created`: QR codes successfully generated
- `400 Bad Request`: Invalid input (missing fields, invalid UUID, quantity out of range)
- `401 Unauthorized`: Missing or invalid authentication token
- `403 Forbidden`: User is not a member of the workspace
- `500 Internal Server Error`: Database or server error during QR code generation

## 5. Data Flow

```
1. Client Request
   ↓
2. Astro Middleware (authentication check)
   ↓
3. API Route Handler (/api/qr-codes/batch.ts)
   - Extract request body
   - Validate with Zod schema
   - Check workspace membership
   ↓
4. Service Layer (qrcode.service.ts::batchGenerateQrCodes)
   - Generate unique short_id for each QR code
   - Prepare batch insert records
   - Execute bulk insert to database
   ↓
5. Database (PostgreSQL)
   - Apply RLS policies (workspace membership check)
   - Execute BEFORE INSERT trigger (generate short_id if not provided)
   - Insert QR code records
   - Return inserted records
   ↓
6. Service Layer
   - Format response according to BatchGenerateQrCodesResponse
   ↓
7. API Route Handler
   - Return JSON response with 201 status
   ↓
8. Client receives generated QR codes
```

**Database Operations:**

```typescript
// Bulk insert QR codes
const records = Array.from({ length: quantity }, () => ({
  workspace_id,
  status: 'generated' as const,
  // short_id will be generated by database trigger
}));

const { data, error } = await supabase
  .from('qr_codes')
  .insert(records)
  .select();
```

**Note:** The database trigger `generate_qr_short_id()` automatically generates unique `short_id` values in the format `QR-XXXXXX` before insert.

## 6. Security Considerations

### Authentication
- **JWT Token Validation:** Handled by Astro middleware (`src/middleware/index.ts`)
- **Token Presence:** Must include `Authorization: Bearer <token>` header
- **Session Validation:** Supabase client validates token and attaches user context
- **User Extraction:** `context.locals.user` contains authenticated user data

### Authorization
- **Workspace Membership:** User must be a member of the workspace to generate QR codes
- **Membership Check:** Verify via `workspace_members` table before generating codes
- **RLS Enforcement:** Row Level Security policies prevent unauthorized access
- **Role Requirements:** All roles (owner, admin, member, read_only) can generate QR codes

### Input Validation
- **UUID Validation:** `workspace_id` must be valid UUID format (Zod)
- **Quantity Validation:** Must be integer between 1 and 100 (Zod)
- **Type Safety:** Zod ensures correct data types
- **SQL Injection Prevention:** Supabase client uses parameterized queries

### Data Integrity
- **Unique Short IDs:** Database trigger ensures uniqueness of `short_id` values
- **Retry Logic:** If short_id collision occurs, trigger retries generation (max 10 attempts)
- **Transaction Safety:** Bulk insert is atomic - either all succeed or all fail
- **Foreign Key Constraints:** `workspace_id` must reference existing workspace

### Rate Limiting
- **Batch Size Limit:** Maximum 100 QR codes per request prevents abuse
- **Consider Future Enhancement:** Implement per-user rate limiting (e.g., max 500 codes/hour)
- **Database Load:** Bulk insert is efficient, but monitoring recommended

### Audit Logging
- Log successful batch generation with user_id, workspace_id, and quantity
- Log validation failures with sanitized input
- Log authorization failures
- Log database errors with context

## 7. Error Handling

### Error Scenarios and Responses (Polish Messages)

**1. Missing workspace_id (400 Bad Request)**
```json
{
  "error": "Nieprawidłowy format workspace_id"
}
```

**2. Invalid workspace_id format (400 Bad Request)**
```json
{
  "error": "Nieprawidłowy format workspace_id"
}
```

**3. Missing quantity (400 Bad Request)**
```json
{
  "error": "Pole quantity jest wymagane"
}
```

**4. Quantity too small (400 Bad Request)**
```json
{
  "error": "Ilość musi wynosić co najmniej 1"
}
```

**5. Quantity too large (400 Bad Request)**
```json
{
  "error": "Ilość nie może przekraczać 100"
}
```

**6. Invalid quantity type (400 Bad Request)**
```json
{
  "error": "Ilość musi być liczbą całkowitą"
}
```

**7. Not authenticated (401 Unauthorized)**
```json
{
  "error": "Brak autoryzacji"
}
```

**8. Not a workspace member (403 Forbidden)**
```json
{
  "error": "Nie masz dostępu do tego obszaru roboczego"
}
```

**9. Workspace does not exist (403 Forbidden)**
```json
{
  "error": "Nie masz dostępu do tego obszaru roboczego"
}
```

**10. Database error during generation (500 Internal Server Error)**
```json
{
  "error": "Nie udało się wygenerować kodów QR"
}
```

**11. Short ID collision (extremely rare, 500 Internal Server Error)**
```json
{
  "error": "Nie udało się wygenerować unikalnych kodów QR. Spróbuj ponownie."
}
```

**12. Invalid JSON in request body (400 Bad Request)**
```json
{
  "error": "Nieprawidłowy format JSON w treści żądania"
}
```

**Error Handling Strategy:**

```typescript
// Input validation errors (Zod)
catch (error) {
  if (error instanceof z.ZodError) {
    return new Response(JSON.stringify({
      error: error.errors[0].message
    }), { status: 400 });
  }
}

// Authorization errors
if (!isMember) {
  return new Response(JSON.stringify({
    error: 'Nie masz dostępu do tego obszaru roboczego'
  }), { status: 403 });
}

// Database errors
catch (error) {
  console.error('[POST /api/qr-codes/batch] Database error:', {
    user_id: context.locals.user?.id,
    workspace_id,
    quantity,
    error: error.message
  });

  return new Response(JSON.stringify({
    error: 'Nie udało się wygenerować kodów QR'
  }), { status: 500 });
}
```

## 8. Performance Considerations

### Bulk Insert Optimization
- **Single Query:** Use Supabase bulk insert (`insert(array)`) instead of individual inserts
- **Batch Size:** Limit to 100 records prevents excessive database load
- **Transaction:** Bulk insert is atomic and efficient
- **Indexing:** Unique index on `short_id` ensures fast collision detection

### Short ID Generation
- **Database Trigger:** Generation happens at database level for consistency
- **Collision Handling:** Trigger includes retry logic (max 10 attempts)
- **Character Set:** 36 characters (A-Z, 0-9) = 36^6 = ~2 billion combinations
- **Collision Probability:** Extremely low for reasonable usage

### Database Load
- **Connection Pooling:** Supabase handles connection pooling automatically
- **Index Usage:** Unique index on `short_id` is used during collision checks
- **Workspace Index:** Index on `workspace_id` speeds up RLS policy checks

### Potential Bottlenecks
- **Short ID Generation:** Very fast, O(1) per code
- **Bulk Insert:** Efficient, scales linearly with quantity
- **RLS Policy Check:** Fast with proper indexing on `workspace_members`
- **Network Latency:** Largest factor for small batches

### Recommended Monitoring
- Track average generation time per batch
- Monitor short_id collision rate (should be near zero)
- Alert if generation failures exceed threshold
- Monitor database connection pool usage

## 9. Implementation Steps

### Step 1: Verify Database Trigger Exists

Check that the `generate_qr_short_id()` trigger is properly implemented:

**Expected Trigger (from db-plan.md):**

```sql
-- Trigger function to generate unique QR short_id
CREATE OR REPLACE FUNCTION generate_qr_short_id()
RETURNS TRIGGER AS $$
DECLARE
  new_short_id TEXT;
  collision_count INT := 0;
  max_retries INT := 10;
BEGIN
  -- Only generate if short_id is not provided
  IF NEW.short_id IS NOT NULL THEN
    RETURN NEW;
  END IF;

  LOOP
    -- Generate QR-XXXXXX format (6 uppercase alphanumeric characters)
    new_short_id := 'QR-' || UPPER(
      substring(md5(random()::text || clock_timestamp()::text) from 1 for 6)
    );

    -- Check for collision
    IF NOT EXISTS (SELECT 1 FROM qr_codes WHERE short_id = new_short_id) THEN
      NEW.short_id := new_short_id;
      RETURN NEW;
    END IF;

    collision_count := collision_count + 1;
    IF collision_count >= max_retries THEN
      RAISE EXCEPTION 'Failed to generate unique short_id after % attempts', max_retries;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to qr_codes table
DROP TRIGGER IF EXISTS trigger_generate_qr_short_id ON qr_codes;
CREATE TRIGGER trigger_generate_qr_short_id
  BEFORE INSERT ON qr_codes
  FOR EACH ROW
  EXECUTE FUNCTION generate_qr_short_id();
```

**Verification Command:**

```sql
-- Check if trigger exists
SELECT tgname, tgrelid::regclass, tgtype
FROM pg_trigger
WHERE tgname = 'trigger_generate_qr_short_id';

-- Check if function exists
SELECT proname, prosrc
FROM pg_proc
WHERE proname = 'generate_qr_short_id';
```

### Step 2: Create Service Layer Function

**File:** `src/lib/services/qrcode.service.ts`

```typescript
import type { SupabaseClient } from '@/db/supabase.client';
import type { BatchGenerateQrCodesRequest, BatchGenerateQrCodesResponse } from '@/types';

/**
 * Verifies that the authenticated user is a member of the specified workspace.
 *
 * @param supabase - Authenticated Supabase client
 * @param workspace_id - UUID of the workspace
 * @param user_id - UUID of the user
 * @returns Promise<boolean> - true if user is a member, false otherwise
 */
export async function isWorkspaceMember(
  supabase: SupabaseClient,
  workspace_id: string,
  user_id: string
): Promise<boolean> {
  const { data, error } = await supabase
    .from('workspace_members')
    .select('user_id')
    .eq('workspace_id', workspace_id)
    .eq('user_id', user_id)
    .single();

  if (error || !data) {
    return false;
  }

  return true;
}

/**
 * Generates a batch of QR codes for a workspace.
 * Creates multiple QR code records with unique short IDs and status 'generated'.
 *
 * @param supabase - Authenticated Supabase client
 * @param request - Batch generation request (workspace_id, quantity)
 * @returns Promise<BatchGenerateQrCodesResponse> - Array of generated QR codes
 * @throws Error if database operation fails or short_id generation fails
 */
export async function batchGenerateQrCodes(
  supabase: SupabaseClient,
  request: BatchGenerateQrCodesRequest
): Promise<BatchGenerateQrCodesResponse> {
  const { workspace_id, quantity } = request;

  // Prepare batch insert records
  // short_id will be auto-generated by database trigger
  const records = Array.from({ length: quantity }, () => ({
    workspace_id,
    status: 'generated' as const,
  }));

  // Bulk insert QR codes
  const { data, error } = await supabase
    .from('qr_codes')
    .insert(records)
    .select('id, short_id, status, workspace_id, created_at');

  if (error) {
    console.error('[QRCodeService] Failed to generate QR codes:', {
      workspace_id,
      quantity,
      error: error.message,
      code: error.code,
    });
    throw new Error('Nie udało się wygenerować kodów QR');
  }

  if (!data || data.length !== quantity) {
    console.error('[QRCodeService] Generated count mismatch:', {
      workspace_id,
      expected: quantity,
      actual: data?.length || 0,
    });
    throw new Error('Nie udało się wygenerować wszystkich kodów QR');
  }

  return {
    data: data.map((qr) => ({
      id: qr.id,
      short_id: qr.short_id,
      status: qr.status,
      workspace_id: qr.workspace_id,
      created_at: qr.created_at,
    })),
  };
}
```

### Step 3: Create API Route Handler

**File:** `src/pages/api/qr-codes/batch.ts`

```typescript
import type { APIContext } from 'astro';
import { z } from 'zod';
import { batchGenerateQrCodes, isWorkspaceMember } from '@/lib/services/qrcode.service';
import type { BatchGenerateQrCodesRequest, ErrorResponse } from '@/types';
import { ValidationRules } from '@/types';

export const prerender = false;

// Validation schema
const BatchGenerateQrCodesRequestSchema = z.object({
  workspace_id: z.string().uuid('Nieprawidłowy format workspace_id'),
  quantity: z
    .number()
    .int('Ilość musi być liczbą całkowitą')
    .min(ValidationRules.qrCodes.MIN_BATCH_QUANTITY, 'Ilość musi wynosić co najmniej 1')
    .max(ValidationRules.qrCodes.MAX_BATCH_QUANTITY, 'Ilość nie może przekraczać 100'),
});

/**
 * POST /api/qr-codes/batch
 * Generates a batch of new QR codes for a workspace.
 */
export async function POST(context: APIContext): Promise<Response> {
  // Authentication check
  const user = context.locals.user;
  if (!user) {
    return new Response(JSON.stringify({ error: 'Brak autoryzacji' } as ErrorResponse), {
      status: 401,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  try {
    // Parse and validate request body
    const body = await context.request.json();
    const validatedRequest = BatchGenerateQrCodesRequestSchema.parse(body);

    // Authorization: Check workspace membership
    const supabase = context.locals.supabase;
    const isMember = await isWorkspaceMember(
      supabase,
      validatedRequest.workspace_id,
      user.id
    );

    if (!isMember) {
      console.warn('[POST /api/qr-codes/batch] Unauthorized workspace access:', {
        user_id: user.id,
        workspace_id: validatedRequest.workspace_id,
      });

      return new Response(
        JSON.stringify({
          error: 'Nie masz dostępu do tego obszaru roboczego',
        } as ErrorResponse),
        {
          status: 403,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Generate QR codes
    const response = await batchGenerateQrCodes(
      supabase,
      validatedRequest as BatchGenerateQrCodesRequest
    );

    // Log success
    console.log('[POST /api/qr-codes/batch] Success:', {
      user_id: user.id,
      workspace_id: validatedRequest.workspace_id,
      quantity: validatedRequest.quantity,
      generated_count: response.data.length,
    });

    return new Response(JSON.stringify(response), {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    // Validation errors
    if (error instanceof z.ZodError) {
      console.error('[POST /api/qr-codes/batch] Validation error:', {
        user_id: user.id,
        errors: error.errors,
      });

      return new Response(
        JSON.stringify({
          error: error.errors[0].message,
        } as ErrorResponse),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // JSON parse errors
    if (error instanceof SyntaxError) {
      console.error('[POST /api/qr-codes/batch] Invalid JSON:', {
        user_id: user.id,
        error: error.message,
      });

      return new Response(
        JSON.stringify({
          error: 'Nieprawidłowy format JSON w treści żądania',
        } as ErrorResponse),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Database/service errors
    console.error('[POST /api/qr-codes/batch] Server error:', {
      user_id: user.id,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    return new Response(
      JSON.stringify({
        error: 'Nie udało się wygenerować kodów QR',
      } as ErrorResponse),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
}
```

### Step 4: Create Test Script

**File:** `.ai_docs/test-post-qr-codes-batch.sh`

```bash
#!/bin/bash

# Test POST /api/qr-codes/batch endpoint

# Configuration (replace with actual values)
BASE_URL="http://localhost:3000"
TOKEN="your-jwt-token-here"
WORKSPACE_ID="your-workspace-id-here"

echo "Testing POST /api/qr-codes/batch endpoint..."
echo "=============================================="

# Test 1: Generate 5 QR codes (success)
echo -e "\nTest 1: Generowanie 5 kodów QR (oczekiwane 201)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 5
  }' \\
| python3 -m json.tool
EOF

# Test 2: Generate 1 QR code (minimum)
echo -e "\nTest 2: Generowanie 1 kodu QR - minimalna ilość (oczekiwane 201)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 1
  }' \\
| python3 -m json.tool
EOF

# Test 3: Generate 100 QR codes (maximum)
echo -e "\nTest 3: Generowanie 100 kodów QR - maksymalna ilość (oczekiwane 201)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 100
  }' \\
| python3 -m json.tool
EOF

# Test 4: Invalid workspace_id (400)
echo -e "\nTest 4: Nieprawidłowy workspace_id (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "invalid-uuid",
    "quantity": 5
  }' \\
| python3 -m json.tool
EOF

# Test 5: Quantity too small (400)
echo -e "\nTest 5: Ilość za mała - 0 (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 0
  }' \\
| python3 -m json.tool
EOF

# Test 6: Quantity too large (400)
echo -e "\nTest 6: Ilość za duża - 101 (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 101
  }' \\
| python3 -m json.tool
EOF

# Test 7: Missing quantity (400)
echo -e "\nTest 7: Brak pola quantity (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID"
  }' \\
| python3 -m json.tool
EOF

# Test 8: Missing workspace_id (400)
echo -e "\nTest 8: Brak pola workspace_id (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "quantity": 5
  }' \\
| python3 -m json.tool
EOF

# Test 9: Invalid quantity type - string (400)
echo -e "\nTest 9: Nieprawidłowy typ quantity - string (oczekiwane 400)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": "five"
  }' \\
| python3 -m json.tool
EOF

# Test 10: Missing authentication (401)
echo -e "\nTest 10: Brak autoryzacji (oczekiwane 401)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "$WORKSPACE_ID",
    "quantity": 5
  }' \\
| python3 -m json.tool
EOF

# Test 11: Non-existent workspace (403)
echo -e "\nTest 11: Nieistniejący obszar roboczy (oczekiwane 403)"
cat <<EOF | bash
curl -s -X POST \\
  $BASE_URL/api/qr-codes/batch \\
  -H "Authorization: Bearer $TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{
    "workspace_id": "00000000-0000-0000-0000-000000000000",
    "quantity": 5
  }' \\
| python3 -m json.tool
EOF

echo -e "\nWszystkie testy zakończone!"
```

### Step 5: Update API Documentation

Update `.ai_docs/api-plan.md` to mark the endpoint as implemented:

```markdown
#### POST /qr-codes/batch

- **Description**: Generates a batch of new, unassigned QR codes for printing.
- **Implementation Status**: ✅ Implemented
- **Implementation File**: `src/pages/api/qr-codes/batch.ts`
- **Service Layer**: `src/lib/services/qrcode.service.ts::batchGenerateQrCodes()`
- **Query Parameters**: None
- **Request JSON**:

```json
{
  "workspace_id": "uuid",
  "quantity": 20
}
```

- **Response JSON** (201 Created):

```json
{
  "data": [
    {
      "id": "uuid-1",
      "short_id": "QR-A1B2C3",
      "status": "generated",
      "workspace_id": "uuid",
      "created_at": "timestamp"
    },
    {
      "id": "uuid-2",
      "short_id": "QR-D4E5F6",
      "status": "generated",
      "workspace_id": "uuid",
      "created_at": "timestamp"
    }
  ]
}
```

- **Errors**:
  - `400 Bad Request`: Nieprawidłowa ilość (np. < 1 lub > 100), nieprawidłowy format workspace_id, brakujące pola
  - `401 Unauthorized`: Brak autoryzacji
  - `403 Forbidden`: Użytkownik nie jest członkiem obszaru roboczego
  - `500 Internal Server Error`: Nie udało się wygenerować kodów QR
```

### Step 6: Verify Database Schema

Ensure the `qr_codes` table and trigger are properly set up:

```sql
-- Verify qr_codes table structure
\d qr_codes

-- Expected columns:
-- id: UUID PRIMARY KEY
-- workspace_id: UUID NOT NULL
-- box_id: UUID (nullable)
-- short_id: TEXT NOT NULL UNIQUE
-- status: qr_status NOT NULL DEFAULT 'generated'
-- created_at: TIMESTAMPTZ DEFAULT now()

-- Verify trigger exists
SELECT tgname FROM pg_trigger WHERE tgrelid = 'qr_codes'::regclass;

-- Expected: trigger_generate_qr_short_id

-- Test short_id generation manually
INSERT INTO qr_codes (workspace_id, status)
VALUES ('your-workspace-id', 'generated')
RETURNING id, short_id, status;

-- Should return a record with short_id like 'QR-A1B2C3'
```

### Step 7: Lint and Format Code

```bash
npm run lint:fix
npm run format
```

### Step 8: Manual Testing Checklist

**Prerequisites:**
1. Start dev server: `npm run dev`
2. Ensure Supabase is running locally
3. Obtain valid JWT token for testing
4. Get workspace_id from your database

**Test Scenarios:**

- [ ] Generate 5 QR codes successfully (201)
- [ ] Verify all short_ids are unique and in format `QR-XXXXXX`
- [ ] Verify all statuses are `generated`
- [ ] Generate 1 QR code (minimum quantity, 201)
- [ ] Generate 100 QR codes (maximum quantity, 201)
- [ ] Test invalid workspace_id format (400 - "Nieprawidłowy format workspace_id")
- [ ] Test quantity = 0 (400 - "Ilość musi wynosić co najmniej 1")
- [ ] Test quantity = 101 (400 - "Ilość nie może przekraczać 100")
- [ ] Test missing quantity field (400)
- [ ] Test missing workspace_id field (400)
- [ ] Test invalid quantity type - string (400 - "Ilość musi być liczbą całkowitą")
- [ ] Test missing authentication header (401 - "Brak autoryzacji")
- [ ] Test with workspace user is not a member of (403 - "Nie masz dostępu do tego obszaru roboczego")
- [ ] Verify RLS policies prevent cross-workspace access
- [ ] Check database logs for any errors
- [ ] Verify generated QR codes are queryable

**Database Verification:**

```sql
-- Check generated QR codes
SELECT id, short_id, status, workspace_id, created_at
FROM qr_codes
WHERE workspace_id = 'your-workspace-id'
ORDER BY created_at DESC
LIMIT 10;

-- Verify all short_ids are unique
SELECT short_id, COUNT(*)
FROM qr_codes
GROUP BY short_id
HAVING COUNT(*) > 1;
-- Should return 0 rows

-- Verify short_id format
SELECT short_id
FROM qr_codes
WHERE short_id NOT SIMILAR TO 'QR-[A-Z0-9]{6}';
-- Should return 0 rows
```

## 10. Completion Checklist

- [ ] Verify database trigger `generate_qr_short_id()` exists and works
- [ ] Create `src/lib/services/qrcode.service.ts` with required functions:
  - [ ] `isWorkspaceMember()` - workspace membership verification
  - [ ] `batchGenerateQrCodes()` - batch QR code generation
- [ ] Create `src/pages/api/qr-codes/batch.ts` with POST handler
- [ ] Implement comprehensive input validation with Zod (Polish error messages)
- [ ] Implement authorization check (workspace membership)
- [ ] Add proper error handling for all scenarios (Polish error messages)
- [ ] Add audit logging for success and error cases
- [ ] Create test script `.ai_docs/test-post-qr-codes-batch.sh`
- [ ] Update `.ai_docs/api-plan.md` with implementation status
- [ ] Run `npm run lint:fix` to ensure code quality
- [ ] Test all success scenarios (1, 5, 100 QR codes)
- [ ] Test all error scenarios (400, 401, 403, 500) with Polish error messages
- [ ] Verify RLS policies work correctly
- [ ] Verify short_id generation and uniqueness
- [ ] Verify all generated QR codes have status `generated`
- [ ] Check database for proper data insertion
- [ ] Performance test with maximum quantity (100)
